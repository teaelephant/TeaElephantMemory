// Package consumption contains storage backends for recent tea consumption events.
package consumption

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"

	"github.com/teaelephant/TeaElephantMemory/pkg/pgstore"
)

// ErrNilDB is returned when the PGStore has not been initialized with a database handle.
var ErrNilDB = errors.New("pg consumption: nil db")

// PGStore is a PostgreSQL-backed implementation of Store.
// It expects the schema defined in db/schema.sql (table: consumptions) and delegates
// SQL execution to code generated by sqlc (pkg/pgstore).
type PGStore struct {
	queries   *pgstore.Queries
	retention time.Duration
}

const defaultRetention = 30 * 24 * time.Hour

// NewPGStore creates a PostgreSQL-backed consumption store with the given retention window.
// If retention <= 0, a default of 30 days is used.
func NewPGStore(pg *sql.DB, retention time.Duration) *PGStore {
	if retention <= 0 {
		retention = defaultRetention
	}
	return &PGStore{queries: pgstore.New(pg), retention: retention}
}

// Record stores a consumption event for a user at a given timestamp, enforcing
// the retention window by pruning older entries for that user.
func (s *PGStore) Record(ctx context.Context, userID uuid.UUID, teaID uuid.UUID, ts time.Time) error {
	if s.queries == nil {
		return ErrNilDB
	}

	if ts.Location() != time.UTC {
		ts = ts.UTC()
	}

	if err := s.queries.InsertConsumption(ctx, pgstore.InsertConsumptionParams{UserID: userID, Ts: ts, TeaID: teaID}); err != nil {
		return fmt.Errorf("pg consumption.Record: insert: %w", err)
	}

	cutoff := ts.Add(-s.retention)
	if err := s.queries.DeleteConsumptionsBefore(ctx, userID, cutoff); err != nil {
		return fmt.Errorf("pg consumption.Record: retention delete: %w", err)
	}

	return nil
}

// Recent returns consumption events since the given time for the user, ordered by time descending.
func (s *PGStore) Recent(ctx context.Context, userID uuid.UUID, since time.Time) ([]Consumption, error) {
	if s.queries == nil {
		return nil, ErrNilDB
	}

	if since.Location() != time.UTC {
		since = since.UTC()
	}

	rows, err := s.queries.ListConsumptionsSince(ctx, pgstore.ListConsumptionsSinceParams{UserID: userID, Since: since})
	if err != nil {
		return nil, fmt.Errorf("pg consumption.Recent: query: %w", err)
	}

	result := make([]Consumption, 0, len(rows))
	for _, row := range rows {
		result = append(result, Consumption{TeaID: row.TeaID, Time: row.Ts})
	}
	return result, nil
}

// EnsurePGConsumptionsTable can be used at startup to verify the schema exists.
// It's a light guard and not a full migration mechanism.
func EnsurePGConsumptionsTable(ctx context.Context, db *sql.DB) error {
	_, err := db.ExecContext(ctx, "SELECT 1 FROM consumptions LIMIT 1")
	if err == nil {
		return nil
	}
	return fmt.Errorf("pg consumption: consumptions table check failed: %w", err)
}

// Ping checks PG connectivity for this store.
func (s *PGStore) Ping(ctx context.Context) error {
	if s.queries == nil {
		return ErrNilDB
	}
	return s.queries.DB().PingContext(ctx)
}
