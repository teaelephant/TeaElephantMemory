// Code generated by github.com/99designs/gqlgen; DO NOT EDIT.
package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"errors"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"

	rootCommon "github.com/teaelephant/TeaElephantMemory/common"
	authPkg "github.com/teaelephant/TeaElephantMemory/internal/auth"
	"github.com/teaelephant/TeaElephantMemory/internal/scoring"
	"github.com/teaelephant/TeaElephantMemory/pkg/api/v2/common"
	"github.com/teaelephant/TeaElephantMemory/pkg/api/v2/graphql/generated"
	model "github.com/teaelephant/TeaElephantMemory/pkg/api/v2/models"
)

var (
	// ErrNoTeas indicates the user has no teas in their collections to select from.
	ErrNoTeas = errors.New("you should have more teas")
	// ErrNoTeaCandidates indicates scoring produced no valid tea candidates.
	ErrNoTeaCandidates = errors.New("no tea candidates")
)

// Records is the resolver for the records field.
func (r *collectionResolver) Records(ctx context.Context, obj *model.Collection) ([]*model.QRRecord, error) {
	return r.ListRecords(ctx, uuid.UUID(obj.ID), uuid.UUID(obj.UserID))
}

// AuthApple is the resolver for the authApple field.
func (r *mutationResolver) AuthApple(ctx context.Context, appleCode string, deviceID common.ID) (*model.Session, error) {
	session, err := r.Auth(ctx, appleCode)
	if err != nil {
		return nil, gqlerror.Wrap(err)
	}

	if err = r.BindDevice(ctx, session.User.ID, uuid.UUID(deviceID)); err != nil {
		return nil, err
	}

	return &model.Session{
		Token:     session.JWT,
		ExpiredAt: session.ExpiredAt,
	}, nil
}

// NewTea is the resolver for the newTea field.
func (r *mutationResolver) NewTea(ctx context.Context, tea model.TeaData) (*model.Tea, error) {
	res, err := r.teaData.Create(ctx, tea.ToCommonTeaData())
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(res), nil
}

// UpdateTea is the resolver for the updateTea field.
func (r *mutationResolver) UpdateTea(ctx context.Context, id common.ID, tea model.TeaData) (*model.Tea, error) {
	res, err := r.teaData.Update(ctx, uuid.UUID(id), tea.ToCommonTeaData())
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(res), nil
}

// AddTagToTea is the resolver for the addTagToTea field.
func (r *mutationResolver) AddTagToTea(ctx context.Context, teaID common.ID, tagID common.ID) (*model.Tea, error) {
	if err := r.tagManager.AddTagToTea(ctx, uuid.UUID(teaID), uuid.UUID(tagID)); err != nil {
		return nil, castGQLError(ctx, err)
	}

	t, err := r.teaData.Get(ctx, uuid.UUID(teaID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(t), nil
}

// DeleteTagFromTea is the resolver for the deleteTagFromTea field.
func (r *mutationResolver) DeleteTagFromTea(ctx context.Context, teaID common.ID, tagID common.ID) (*model.Tea, error) {
	if err := r.tagManager.DeleteTagFromTea(ctx, uuid.UUID(teaID), uuid.UUID(tagID)); err != nil {
		return nil, castGQLError(ctx, err)
	}

	t, err := r.teaData.Get(ctx, uuid.UUID(teaID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(t), nil
}

// DeleteTea is the resolver for the deleteTea field.
func (r *mutationResolver) DeleteTea(ctx context.Context, id common.ID) (common.ID, error) {
	if err := r.teaData.Delete(ctx, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// WriteToQR is the resolver for the writeToQR field.
func (r *mutationResolver) WriteToQR(ctx context.Context, id common.ID, data model.QRRecordData) (*model.QRRecord, error) {
	if err := r.Set(ctx, uuid.UUID(id), &data); err != nil {
		return nil, castGQLError(ctx, err)
	}

	tea, err := r.teaData.Get(ctx, uuid.UUID(data.Tea))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.QRRecord{
		ID: id,
		Tea: &model.Tea{
			ID:          common.ID(tea.ID),
			Name:        tea.Name,
			Type:        model.FromBeverageType(tea.Type),
			Description: tea.Description,
		},
		BowlingTemp:    data.BowlingTemp,
		ExpirationDate: data.ExpirationDate,
	}, nil
}

// CreateTagCategory is the resolver for the createTagCategory field.
func (r *mutationResolver) CreateTagCategory(ctx context.Context, name string) (*model.TagCategory, error) {
	category, err := r.CreateCategory(ctx, name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.TagCategory{
		ID:   common.ID(category.ID),
		Name: category.Name,
	}, nil
}

// UpdateTagCategory is the resolver for the updateTagCategory field.
func (r *mutationResolver) UpdateTagCategory(ctx context.Context, id common.ID, name string) (*model.TagCategory, error) {
	cat, err := r.UpdateCategory(ctx, uuid.UUID(id), name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.TagCategory{
		ID:   common.ID(cat.ID),
		Name: cat.Name,
	}, nil
}

// DeleteTagCategory is the resolver for the deleteTagCategory field.
func (r *mutationResolver) DeleteTagCategory(ctx context.Context, id common.ID) (common.ID, error) {
	if err := r.DeleteCategory(ctx, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, name string, color string, category common.ID) (*model.Tag, error) {
	tag, err := r.tagManager.Create(ctx, name, color, uuid.UUID(category))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
	}, nil
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id common.ID, name string, color string) (*model.Tag, error) {
	tag, err := r.tagManager.Update(ctx, uuid.UUID(id), name, color)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
	}, nil
}

// ChangeTagCategory is the resolver for the changeTagCategory field.
func (r *mutationResolver) ChangeTagCategory(ctx context.Context, id common.ID, category common.ID) (*model.Tag, error) {
	tag, err := r.ChangeCategory(ctx, uuid.UUID(id), uuid.UUID(category))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
	}, nil
}

// DeleteTag is the resolver for the deleteTag field.
func (r *mutationResolver) DeleteTag(ctx context.Context, id common.ID) (common.ID, error) {
	if err := r.tagManager.Delete(ctx, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, name string) (*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	col, err := r.collectionManager.Create(ctx, user.ID, name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return col, nil
}

// AddRecordsToCollection is the resolver for the addRecordsToCollection field.
func (r *mutationResolver) AddRecordsToCollection(ctx context.Context, id common.ID, records []common.ID) (*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	ids := make([]uuid.UUID, len(records))
	for i, uid := range records {
		ids[i] = uuid.UUID(uid)
	}

	col, err := r.AddRecords(ctx, user.ID, uuid.UUID(id), ids)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return col, nil
}

// DeleteRecordsFromCollection is the resolver for the deleteRecordsFromCollection field.
func (r *mutationResolver) DeleteRecordsFromCollection(ctx context.Context, id common.ID, records []common.ID) (*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	ids := make([]uuid.UUID, len(records))
	for i, uid := range records {
		ids[i] = uuid.UUID(uid)
	}

	col, err := r.DeleteRecords(ctx, user.ID, uuid.UUID(id), ids)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return col, nil
}

// DeleteCollection is the resolver for the deleteCollection field.
func (r *mutationResolver) DeleteCollection(ctx context.Context, id common.ID) (common.ID, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	if err := r.collectionManager.Delete(ctx, user.ID, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// RegisterDeviceToken is the resolver for the registerDeviceToken field.
func (r *mutationResolver) RegisterDeviceToken(ctx context.Context, deviceID common.ID, deviceToken string) (bool, error) {
	if err := r.notificationsManager.RegisterDeviceToken(ctx, uuid.UUID(deviceID), deviceToken); err != nil {
		return false, castGQLError(ctx, err)
	}

	return true, nil
}

// Send is the resolver for the send field.
func (r *mutationResolver) Send(ctx context.Context) (bool, error) {
	_, err := authPkg.GetUser(ctx)
	if err != nil {
		return false, castGQLError(ctx, err)
	}

	if err = r.Run(ctx); err != nil {
		return false, castGQLError(ctx, err)
	}

	return true, nil
}

// TeaRecommendation is the resolver for the teaRecommendation field.
func (r *mutationResolver) TeaRecommendation(ctx context.Context, collectionID common.ID, feelings string) (string, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	wth, err := r.CurrentCyprus(ctx)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	records, err := r.ListRecords(ctx, uuid.UUID(collectionID), user.ID)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	if len(records) == 0 {
		return "", ErrNoTeas
	}

	teas := make([]rootCommon.Tea, len(records))

	for i, rec := range records {
		teas[i] = rec.Tea.ToCommonTea()
	}

	res, err := r.RecommendTea(ctx, teas, wth, feelings)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	return res, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.User{TokenExpiredAt: user.ExpiredAt}, nil
}

// Teas is the resolver for the teas field.
func (r *queryResolver) Teas(ctx context.Context, prefix *string) ([]*model.Tea, error) {
	res, err := r.teaData.List(ctx, prefix)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	data := make([]*model.Tea, len(res))
	for i, el := range res {
		data[i] = model.FromCommonTea(&el)
	}

	return data, nil
}

// Tea is the resolver for the tea field.
func (r *queryResolver) Tea(ctx context.Context, id common.ID) (*model.Tea, error) {
	res, err := r.teaData.Get(ctx, uuid.UUID(id))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(res), nil
}

// GenerateDescription is the resolver for the generateDescription field.
func (r *queryResolver) GenerateDescription(ctx context.Context, name string) (string, error) {
	res, err := r.ai.GenerateDescription(ctx, name)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	return res, nil
}

// QRRecord is the resolver for the qrRecord field.
func (r *queryResolver) QRRecord(ctx context.Context, id common.ID) (*model.QRRecord, error) {
	qr, err := r.qrManager.Get(ctx, uuid.UUID(id))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	res, err := r.teaData.Get(ctx, uuid.UUID(qr.Tea))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.QRRecord{
		ID:             id,
		Tea:            model.FromCommonTea(res),
		BowlingTemp:    qr.BowlingTemp,
		ExpirationDate: qr.ExpirationDate,
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id common.ID) (*model.Tag, error) {
	tag, err := r.tagManager.Get(ctx, uuid.UUID(id))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
		Category: &model.TagCategory{
			ID: common.ID(tag.CategoryID),
		},
	}, nil
}

// TagsCategories is the resolver for the tagsCategories field.
func (r *queryResolver) TagsCategories(ctx context.Context, name *string) ([]*model.TagCategory, error) {
	categories, err := r.ListCategory(ctx, name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	result := make([]*model.TagCategory, len(categories))
	for i, cat := range categories {
		result[i] = &model.TagCategory{
			ID:   common.ID(cat.ID),
			Name: cat.Name,
		}
	}

	return result, nil
}

// Collections is the resolver for the collections field.
func (r *queryResolver) Collections(ctx context.Context) ([]*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	cols, err := r.collectionManager.List(ctx, user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return cols, nil
}

// TeaOfTheDay is the resolver for the teaOfTheDay field.
//
//nolint:funlen // complex resolver that aggregates data from multiple sources; consider refactor later
func (r *queryResolver) TeaOfTheDay(ctx context.Context) (*model.TeaOfTheDay, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	now := time.Now()
	// Try cache first: cache is per-user and expires at next local midnight.
	if cached, ok := r.todCache.Get(user.ID, now); ok {
		if r.log != nil {
			r.log.
				WithField("user", user.ID.String()).
				WithField("date", now.Format(time.RFC3339)).
				WithField("tea", cached.Tea.Name).
				WithField("tea_id", uuid.UUID(cached.Tea.ID).String()).
				Debug("tea_of_day cache_hit")
		}
		return cached, nil
	}

	// Aggregate all teas from user's collections and track earliest expiration per tea
	cols, err := r.collectionManager.List(ctx, user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	earlyExp := make(map[common.ID]time.Time)
	teas := make(map[common.ID]*model.Tea)

	for _, c := range cols {
		records, err := r.ListRecords(ctx, uuid.UUID(c.ID), user.ID)
		if err != nil {
			return nil, castGQLError(ctx, err)
		}

		for _, rec := range records {
			if rec.Tea == nil {
				continue
			}

			id := rec.Tea.ID
			if _, ok := teas[id]; !ok {
				teas[id] = rec.Tea
				earlyExp[id] = rec.ExpirationDate
			} else if rec.ExpirationDate.Before(earlyExp[id]) {
				earlyExp[id] = rec.ExpirationDate
			}
		}
	}

	if len(teas) == 0 {
		return nil, ErrNoTeas
	}

	// Weather (graceful fallback if error)
	w, _ := r.CurrentCyprus(ctx) //nolint:errcheck // graceful fallback on weather errors

	// Recent consumption for last 4 days
	recent, _ := r.consumption.Recent(ctx, user.ID, now.Add(-96*time.Hour)) //nolint:errcheck // best-effort recent consumption

	lastByTea := make(map[uuid.UUID]time.Time)
	for _, c := range recent {
		if t, ok := lastByTea[c.TeaID]; !ok || c.Time.After(t) {
			lastByTea[c.TeaID] = c.Time
		}
	}

	// Prepare candidates and name mappings
	names := make([]string, 0, len(teas))
	nameToID := make(map[string]uuid.UUID, len(teas))

	candidates := make([]scoring.Candidate, 0, len(teas))
	for id, tea := range teas {
		uid := uuid.UUID(id)
		lc := strings.ToLower(strings.TrimSpace(tea.Name))
		names = append(names, tea.Name)
		nameToID[lc] = uid
		candidates = append(candidates, scoring.Candidate{ID: uid, Name: tea.Name, Expiration: earlyExp[id]})
	}

	// Ask AI for context scores (weather + day-of-week)
	ctxScoresByName, _ := r.ContextScores(ctx, names, w, now.Weekday()) //nolint:errcheck // prefer recommendation even if AI scoring fails

	aiScores := make(map[uuid.UUID]int, len(ctxScoresByName))
	for name, score := range ctxScoresByName {
		if id, ok := nameToID[strings.ToLower(strings.TrimSpace(name))]; ok {
			aiScores[id] = score
		}
	}

	// Convert lastByTea keys to uuid for scoring
	lastBy := make(map[uuid.UUID]time.Time, len(lastByTea))
	for id, t := range lastByTea {
		lastBy[id] = t
	}

	// Debug scoring breakdown for each candidate (ai, recent penalty, expiration bonus, total)
	if r.log != nil {
		weekday := now.Weekday()
		// weather string if available
		var wStr string
		if (w != rootCommon.Weather{}) {
			wStr = w.String()
		}
		r.log.
			WithField("user", user.ID.String()).
			WithField("weekday", weekday.String()).
			WithField("weather", wStr).
			WithField("candidates", len(candidates)).
			Debug("tea_of_day context")

		for _, c := range candidates {
			aiRaw := aiScores[c.ID]
			aiClamped := aiRaw
			if aiClamped < 0 {
				aiClamped = 0
			} else if aiClamped > 15 {
				aiClamped = 15
			}

			recentPenalty := 0
			if last, ok := lastBy[c.ID]; ok {
				diff := now.Sub(last)
				if diff <= 24*time.Hour {
					recentPenalty = -5
				} else if diff <= 48*time.Hour {
					recentPenalty = -3
				}
			}

			expBonus := 0
			if !c.Expiration.IsZero() {
				delta := c.Expiration.Sub(now)
				if delta <= 7*24*time.Hour {
					expBonus = 5
				} else if delta <= 30*24*time.Hour {
					expBonus = 2
				}
			}

			total := aiClamped + recentPenalty + expBonus

			var lastStr string
			if t, ok := lastBy[c.ID]; ok {
				lastStr = t.Format(time.RFC3339)
			} else {
				lastStr = "-"
			}
			var expStr string
			if !c.Expiration.IsZero() {
				expStr = c.Expiration.Format(time.RFC3339)
			} else {
				expStr = "-"
			}

			r.log.
				WithField("name", c.Name).
				WithField("id", c.ID.String()).
				WithField("aiRaw", aiRaw).
				WithField("aiClamped", aiClamped).
				WithField("recentPenalty", recentPenalty).
				WithField("expirationBonus", expBonus).
				WithField("total", total).
				WithField("lastConsumption", lastStr).
				WithField("expiration", expStr).
				Debug("tea_of_day candidate")
		}
	}

	bestID, bestTotal := scoring.SelectBest(aiScores, candidates, lastBy, now)
	if bestID == uuid.Nil {
		return nil, ErrNoTeaCandidates
	}

	// Log final selection with breakdown
	if r.log != nil {
		// find candidate object for expiration/name
		var chosen scoring.Candidate
		for _, c := range candidates {
			if c.ID == bestID {
				chosen = c
				break
			}
		}
		aiRaw := aiScores[bestID]
		aiClamped := aiRaw
		if aiClamped < 0 {
			aiClamped = 0
		} else if aiClamped > 15 {
			aiClamped = 15
		}
		recentPenalty := 0
		if last, ok := lastBy[bestID]; ok {
			diff := now.Sub(last)
			if diff <= 24*time.Hour {
				recentPenalty = -5
			} else if diff <= 48*time.Hour {
				recentPenalty = -3
			}
		}
		expBonus := 0
		if !chosen.Expiration.IsZero() {
			delta := chosen.Expiration.Sub(now)
			if delta <= 7*24*time.Hour {
				expBonus = 5
			} else if delta <= 30*24*time.Hour {
				expBonus = 2
			}
		}
		var lastStr string
		if t, ok := lastBy[bestID]; ok {
			lastStr = t.Format(time.RFC3339)
		} else {
			lastStr = "-"
		}
		var expStr string
		if !chosen.Expiration.IsZero() {
			expStr = chosen.Expiration.Format(time.RFC3339)
		} else {
			expStr = "-"
		}
		r.log.
			WithField("name", chosen.Name).
			WithField("id", bestID.String()).
			WithField("total", bestTotal).
			WithField("aiClamped", aiClamped).
			WithField("recentPenalty", recentPenalty).
			WithField("expirationBonus", expBonus).
			WithField("lastConsumption", lastStr).
			WithField("expiration", expStr).
			Debug("tea_of_day selected")
	}

	best := teas[common.ID(bestID)]
	_ = r.consumption.Record(ctx, user.ID, bestID, now) //nolint:errcheck // best-effort record of consumption

	res := &model.TeaOfTheDay{Tea: best, Date: now}
	r.todCache.Set(user.ID, res, now)
	return res, nil
}

// OnCreateTea is the resolver for the onCreateTea field.
func (r *subscriptionResolver) OnCreateTea(ctx context.Context) (<-chan *model.Tea, error) {
	ch, err := r.teaData.SubscribeOnCreate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnUpdateTea is the resolver for the onUpdateTea field.
func (r *subscriptionResolver) OnUpdateTea(ctx context.Context) (<-chan *model.Tea, error) {
	r.log.Debug("subscribe on update")

	ch, err := r.teaData.SubscribeOnUpdate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnDeleteTea is the resolver for the onDeleteTea field.
func (r *subscriptionResolver) OnDeleteTea(ctx context.Context) (<-chan common.ID, error) {
	ch, err := r.teaData.SubscribeOnDelete(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnCreateTagCategory is the resolver for the onCreateTagCategory field.
func (r *subscriptionResolver) OnCreateTagCategory(ctx context.Context) (<-chan *model.TagCategory, error) {
	ch, err := r.SubscribeOnCreateCategory(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnUpdateTagCategory is the resolver for the onUpdateTagCategory field.
func (r *subscriptionResolver) OnUpdateTagCategory(ctx context.Context) (<-chan *model.TagCategory, error) {
	return r.SubscribeOnUpdateCategory(ctx)
}

// OnDeleteTagCategory is the resolver for the onDeleteTagCategory field.
func (r *subscriptionResolver) OnDeleteTagCategory(ctx context.Context) (<-chan common.ID, error) {
	return r.SubscribeOnDeleteCategory(ctx)
}

// OnCreateTag is the resolver for the onCreateTag field.
func (r *subscriptionResolver) OnCreateTag(ctx context.Context) (<-chan *model.Tag, error) {
	ch, err := r.tagManager.SubscribeOnCreate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnUpdateTag is the resolver for the onUpdateTag field.
func (r *subscriptionResolver) OnUpdateTag(ctx context.Context) (<-chan *model.Tag, error) {
	ch, err := r.tagManager.SubscribeOnUpdate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnDeleteTag is the resolver for the onDeleteTag field.
func (r *subscriptionResolver) OnDeleteTag(ctx context.Context) (<-chan common.ID, error) {
	ch, err := r.tagManager.SubscribeOnDelete(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnAddTagToTea is the resolver for the onAddTagToTea field.
func (r *subscriptionResolver) OnAddTagToTea(ctx context.Context) (<-chan *model.Tea, error) {
	ch, err := r.SubscribeOnAddTagToTea(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnDeleteTagFromTea is the resolver for the onDeleteTagFromTea field.
func (r *subscriptionResolver) OnDeleteTagFromTea(ctx context.Context) (<-chan *model.Tea, error) {
	ch, err := r.SubscribeOnDeleteTagToTea(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// StartGenerateDescription is the resolver for the startGenerateDescription field.
func (r *subscriptionResolver) StartGenerateDescription(ctx context.Context, name string) (<-chan string, error) {
	res := make(chan string, 1)
	if err := r.ai.StartGenerateDescription(ctx, name, res); err != nil {
		return nil, castGQLError(ctx, err)
	}

	return res, nil
}

// RecommendTea is the resolver for the recommendTea field.
func (r *subscriptionResolver) RecommendTea(ctx context.Context, collectionID common.ID, feelings string) (<-chan string, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	wth, err := r.CurrentCyprus(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	records, err := r.ListRecords(ctx, uuid.UUID(collectionID), user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	if len(records) == 0 {
		return nil, ErrNoTeas
	}

	teas := make([]rootCommon.Tea, len(records))

	for i, rec := range records {
		teas[i] = rec.Tea.ToCommonTea()
	}

	res := make(chan string, 1000)
	if err = r.RecommendTeaStream(ctx, teas, wth, feelings, res); err != nil {
		return nil, castGQLError(ctx, err)
	}

	return res, nil
}

// Category is the resolver for the category field.
func (r *tagResolver) Category(ctx context.Context, obj *model.Tag) (*model.TagCategory, error) {
	if obj.Category == nil {
		return nil, nil //nolint:nilnil // GraphQL field can legitimately be null without error
	}

	if obj.Category.Name != "" {
		return obj.Category, nil
	}

	cat, err := r.GetCategory(ctx, uuid.UUID(obj.Category.ID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.TagCategory{
		ID:   common.ID(cat.ID),
		Name: cat.Name,
	}, nil
}

// Tags is the resolver for the tags field.
func (r *tagCategoryResolver) Tags(ctx context.Context, obj *model.TagCategory, name *string) ([]*model.Tag, error) {
	var cat uuid.UUID
	if obj != nil {
		cat = uuid.UUID(obj.ID)
	}

	tags, err := r.tagManager.List(ctx, name, &cat)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	result := make([]*model.Tag, len(tags))
	if len(tags) == 0 {
		return result, nil
	}

	categories, err := r.ListCategory(ctx, nil)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	catMap := map[uuid.UUID]*model.TagCategory{}
	for _, ctg := range categories {
		catMap[ctg.ID] = &model.TagCategory{
			ID:   common.ID(ctg.ID),
			Name: ctg.Name,
		}
	}

	for i, tag := range tags {
		result[i] = &model.Tag{
			ID:       common.ID(tag.ID),
			Name:     tag.Name,
			Color:    tag.Color,
			Category: catMap[tag.CategoryID],
		}
	}

	return result, nil
}

// Tags is the resolver for the tags field.
func (r *teaResolver) Tags(ctx context.Context, obj *model.Tea) ([]*model.Tag, error) {
	tags, err := r.ListByTea(ctx, uuid.UUID(obj.ID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	result := make([]*model.Tag, len(tags))
	for i, t := range tags {
		result[i] = &model.Tag{
			ID:       common.ID(t.ID),
			Name:     t.Name,
			Color:    t.Color,
			Category: &model.TagCategory{ID: common.ID(t.CategoryID)},
		}
	}

	return result, nil
}

// Collections is the resolver for the collections field.
func (r *userResolver) Collections(ctx context.Context, _ *model.User) ([]*model.Collection, error) {
	// Delegate to query-level collections (current authenticated user)
	cols, err := r.Query().Collections(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return cols, nil
}

// Notifications is the resolver for the notifications field.
func (r *userResolver) Notifications(ctx context.Context, _ *model.User) ([]*model.Notification, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	notifications, err := r.notificationsManager.Notifications(ctx, user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	res := make([]*model.Notification, len(notifications))

	for i, not := range notifications {
		t := new(model.NotificationType)
		t.FromCommon(not.Type)
		res[i] = &model.Notification{Type: *t}
	}

	return res, nil
}

// Collection returns generated.CollectionResolver implementation.
func (r *Resolver) Collection() generated.CollectionResolver { return &collectionResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// Tag returns generated.TagResolver implementation.
func (r *Resolver) Tag() generated.TagResolver { return &tagResolver{r} }

// TagCategory returns generated.TagCategoryResolver implementation.
func (r *Resolver) TagCategory() generated.TagCategoryResolver { return &tagCategoryResolver{r} }

// Tea returns generated.TeaResolver implementation.
func (r *Resolver) Tea() generated.TeaResolver { return &teaResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type collectionResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
type tagCategoryResolver struct{ *Resolver }
type teaResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
