package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"

	rootCommon "github.com/teaelephant/TeaElephantMemory/common"
	authPkg "github.com/teaelephant/TeaElephantMemory/internal/auth"
	"github.com/teaelephant/TeaElephantMemory/internal/scoring"
	"github.com/teaelephant/TeaElephantMemory/pkg/api/v2/common"
	"github.com/teaelephant/TeaElephantMemory/pkg/api/v2/graphql/generated"
	model "github.com/teaelephant/TeaElephantMemory/pkg/api/v2/models"
)

// Records is the resolver for the records field.
func (r *collectionResolver) Records(ctx context.Context, obj *model.Collection) ([]*model.QRRecord, error) {
	return r.ListRecords(ctx, uuid.UUID(obj.ID), uuid.UUID(obj.UserID))
}

// AuthApple is the resolver for the authApple field.
func (r *mutationResolver) AuthApple(ctx context.Context, appleCode string, deviceID common.ID) (*model.Session, error) {
	session, err := r.Auth(ctx, appleCode)
	if err != nil {
		return nil, gqlerror.Wrap(err)
	}

	if err = r.BindDevice(ctx, session.User.ID, uuid.UUID(deviceID)); err != nil {
		return nil, err
	}

	return &model.Session{
		Token:     session.JWT,
		ExpiredAt: session.ExpiredAt,
	}, nil
}

// NewTea is the resolver for the newTea field.
func (r *mutationResolver) NewTea(ctx context.Context, tea model.TeaData) (*model.Tea, error) {
	res, err := r.teaData.Create(ctx, tea.ToCommonTeaData())
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(res), nil
}

// UpdateTea is the resolver for the updateTea field.
func (r *mutationResolver) UpdateTea(ctx context.Context, id common.ID, tea model.TeaData) (*model.Tea, error) {
	res, err := r.teaData.Update(ctx, uuid.UUID(id), tea.ToCommonTeaData())
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(res), nil
}

// AddTagToTea is the resolver for the addTagToTea field.
func (r *mutationResolver) AddTagToTea(ctx context.Context, teaID common.ID, tagID common.ID) (*model.Tea, error) {
	if err := r.tagManager.AddTagToTea(ctx, uuid.UUID(teaID), uuid.UUID(tagID)); err != nil {
		return nil, castGQLError(ctx, err)
	}

	t, err := r.teaData.Get(ctx, uuid.UUID(teaID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(t), nil
}

// DeleteTagFromTea is the resolver for the deleteTagFromTea field.
func (r *mutationResolver) DeleteTagFromTea(ctx context.Context, teaID common.ID, tagID common.ID) (*model.Tea, error) {
	if err := r.tagManager.DeleteTagFromTea(ctx, uuid.UUID(teaID), uuid.UUID(tagID)); err != nil {
		return nil, castGQLError(ctx, err)
	}

	t, err := r.teaData.Get(ctx, uuid.UUID(teaID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(t), nil
}

// DeleteTea is the resolver for the deleteTea field.
func (r *mutationResolver) DeleteTea(ctx context.Context, id common.ID) (common.ID, error) {
	if err := r.teaData.Delete(ctx, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// WriteToQR is the resolver for the writeToQR field.
func (r *mutationResolver) WriteToQR(ctx context.Context, id common.ID, data model.QRRecordData) (*model.QRRecord, error) {
	if err := r.Set(ctx, uuid.UUID(id), &data); err != nil {
		return nil, castGQLError(ctx, err)
	}

	tea, err := r.teaData.Get(ctx, uuid.UUID(data.Tea))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.QRRecord{
		ID: id,
		Tea: &model.Tea{
			ID:          common.ID(tea.ID),
			Name:        tea.Name,
			Type:        model.FromBeverageType(tea.Type),
			Description: tea.Description,
		},
		BowlingTemp:    data.BowlingTemp,
		ExpirationDate: data.ExpirationDate,
	}, nil
}

// CreateTagCategory is the resolver for the createTagCategory field.
func (r *mutationResolver) CreateTagCategory(ctx context.Context, name string) (*model.TagCategory, error) {
	category, err := r.CreateCategory(ctx, name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.TagCategory{
		ID:   common.ID(category.ID),
		Name: category.Name,
	}, nil
}

// UpdateTagCategory is the resolver for the updateTagCategory field.
func (r *mutationResolver) UpdateTagCategory(ctx context.Context, id common.ID, name string) (*model.TagCategory, error) {
	cat, err := r.UpdateCategory(ctx, uuid.UUID(id), name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.TagCategory{
		ID:   common.ID(cat.ID),
		Name: cat.Name,
	}, nil
}

// DeleteTagCategory is the resolver for the deleteTagCategory field.
func (r *mutationResolver) DeleteTagCategory(ctx context.Context, id common.ID) (common.ID, error) {
	if err := r.DeleteCategory(ctx, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, name string, color string, category common.ID) (*model.Tag, error) {
	tag, err := r.tagManager.Create(ctx, name, color, uuid.UUID(category))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
	}, nil
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id common.ID, name string, color string) (*model.Tag, error) {
	tag, err := r.tagManager.Update(ctx, uuid.UUID(id), name, color)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
	}, nil
}

// ChangeTagCategory is the resolver for the changeTagCategory field.
func (r *mutationResolver) ChangeTagCategory(ctx context.Context, id common.ID, category common.ID) (*model.Tag, error) {
	tag, err := r.ChangeCategory(ctx, uuid.UUID(id), uuid.UUID(category))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
	}, nil
}

// DeleteTag is the resolver for the deleteTag field.
func (r *mutationResolver) DeleteTag(ctx context.Context, id common.ID) (common.ID, error) {
	if err := r.tagManager.Delete(ctx, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, name string) (*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	col, err := r.collectionManager.Create(ctx, user.ID, name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return col, nil
}

// AddRecordsToCollection is the resolver for the addRecordsToCollection field.
func (r *mutationResolver) AddRecordsToCollection(ctx context.Context, id common.ID, records []common.ID) (*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	ids := make([]uuid.UUID, len(records))
	for i, uid := range records {
		ids[i] = uuid.UUID(uid)
	}

	col, err := r.AddRecords(ctx, user.ID, uuid.UUID(id), ids)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return col, nil
}

// DeleteRecordsFromCollection is the resolver for the deleteRecordsFromCollection field.
func (r *mutationResolver) DeleteRecordsFromCollection(ctx context.Context, id common.ID, records []common.ID) (*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	ids := make([]uuid.UUID, len(records))
	for i, uid := range records {
		ids[i] = uuid.UUID(uid)
	}

	col, err := r.DeleteRecords(ctx, user.ID, uuid.UUID(id), ids)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return col, nil
}

// DeleteCollection is the resolver for the deleteCollection field.
func (r *mutationResolver) DeleteCollection(ctx context.Context, id common.ID) (common.ID, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	if err := r.collectionManager.Delete(ctx, user.ID, uuid.UUID(id)); err != nil {
		return common.ID{}, castGQLError(ctx, err)
	}

	return id, nil
}

// RegisterDeviceToken is the resolver for the registerDeviceToken field.
func (r *mutationResolver) RegisterDeviceToken(ctx context.Context, deviceID common.ID, deviceToken string) (bool, error) {
	if err := r.notificationsManager.RegisterDeviceToken(ctx, uuid.UUID(deviceID), deviceToken); err != nil {
		return false, castGQLError(ctx, err)
	}

	return true, nil
}

// Send is the resolver for the send field.
func (r *mutationResolver) Send(ctx context.Context) (bool, error) {
	_, err := authPkg.GetUser(ctx)
	if err != nil {
		return false, castGQLError(ctx, err)
	}

	if err = r.Run(ctx); err != nil {
		return false, castGQLError(ctx, err)
	}

	return true, nil
}

// TeaRecommendation is the resolver for the teaRecommendation field.
func (r *mutationResolver) TeaRecommendation(ctx context.Context, collectionID common.ID, feelings string) (string, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	wth, err := r.CurrentCyprus(ctx)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	records, err := r.ListRecords(ctx, uuid.UUID(collectionID), user.ID)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	if len(records) == 0 {
		return "", ErrNoTeas
	}

	teas := make([]rootCommon.Tea, len(records))

	for i, rec := range records {
		teas[i] = rec.Tea.ToCommonTea()
	}

	res, err := r.RecommendTea(ctx, teas, wth, feelings)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	return res, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.User{TokenExpiredAt: user.ExpiredAt}, nil
}

// Teas is the resolver for the teas field.
func (r *queryResolver) Teas(ctx context.Context, prefix *string) ([]*model.Tea, error) {
	res, err := r.teaData.List(ctx, prefix)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	data := make([]*model.Tea, len(res))
	for i, el := range res {
		data[i] = model.FromCommonTea(&el)
	}

	return data, nil
}

// Tea is the resolver for the tea field.
func (r *queryResolver) Tea(ctx context.Context, id common.ID) (*model.Tea, error) {
	res, err := r.teaData.Get(ctx, uuid.UUID(id))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return model.FromCommonTea(res), nil
}

// GenerateDescription is the resolver for the generateDescription field.
func (r *queryResolver) GenerateDescription(ctx context.Context, name string) (string, error) {
	res, err := r.ai.GenerateDescription(ctx, name)
	if err != nil {
		return "", castGQLError(ctx, err)
	}

	return res, nil
}

// QRRecord is the resolver for the qrRecord field.
func (r *queryResolver) QRRecord(ctx context.Context, id common.ID) (*model.QRRecord, error) {
	qr, err := r.qrManager.Get(ctx, uuid.UUID(id))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	res, err := r.teaData.Get(ctx, uuid.UUID(qr.Tea))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.QRRecord{
		ID:             id,
		Tea:            model.FromCommonTea(res),
		BowlingTemp:    qr.BowlingTemp,
		ExpirationDate: qr.ExpirationDate,
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id common.ID) (*model.Tag, error) {
	tag, err := r.tagManager.Get(ctx, uuid.UUID(id))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.Tag{
		ID:    common.ID(tag.ID),
		Name:  tag.Name,
		Color: tag.Color,
		Category: &model.TagCategory{
			ID: common.ID(tag.CategoryID),
		},
	}, nil
}

// TagsCategories is the resolver for the tagsCategories field.
func (r *queryResolver) TagsCategories(ctx context.Context, name *string) ([]*model.TagCategory, error) {
	categories, err := r.ListCategory(ctx, name)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	result := make([]*model.TagCategory, len(categories))
	for i, cat := range categories {
		result[i] = &model.TagCategory{
			ID:   common.ID(cat.ID),
			Name: cat.Name,
		}
	}

	return result, nil
}

// Collections is the resolver for the collections field.
func (r *queryResolver) Collections(ctx context.Context) ([]*model.Collection, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	cols, err := r.collectionManager.List(ctx, user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return cols, nil
}

// TeaOfTheDay is the resolver for the teaOfTheDay field.
func (r *queryResolver) TeaOfTheDay(ctx context.Context) (*model.TeaOfTheDay, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	now := time.Now()
	// Try cache first: cache is per-user and expires at next local midnight.
	if cached, ok := r.todCache.Get(user.ID, now); ok {
		if r.log != nil {
			r.log.
				WithField(logKeyUser, user.ID.String()).
				WithField("date", now.Format(time.RFC3339)).
				WithField("tea", cached.Tea.Tea.Name).
				WithField("tea_id", uuid.UUID(cached.Tea.Tea.ID).String()).
				Debug("tea_of_day cache_hit")
		}
		return cached, nil
	}

	// Aggregate all teas from user's collections and track earliest expiration per tea
	cols, err := r.collectionManager.List(ctx, user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	earliestRec := make(map[common.ID]*model.QRRecord)
	// Build candidates and name mappings on the fly to avoid extra iteration.
	candidates := make([]scoring.Candidate, 0, 32)
	names := make([]string, 0, 32)
	nameToID := make(map[string]uuid.UUID, 32)
	idToIdx := make(map[uuid.UUID]int, 32)

	for _, c := range cols {
		records, err := r.ListRecords(ctx, uuid.UUID(c.ID), user.ID)
		if err != nil {
			return nil, castGQLError(ctx, err)
		}

		for _, rec := range records {
			if rec.Tea == nil {
				continue
			}

			idCommon := rec.Tea.ID
			uid := uuid.UUID(idCommon)
			name := rec.Tea.Name

			if prev, seen := earliestRec[idCommon]; !seen {
				// first time we see this tea: record earliestRec and add candidate + name mappings
				earliestRec[idCommon] = rec
				candidates = append(candidates, scoring.Candidate{ID: uid, Name: name, Expiration: rec.ExpirationDate})
				idToIdx[uid] = len(candidates) - 1
				names = append(names, name)
				nameToID[strings.ToLower(strings.TrimSpace(name))] = uid
			} else if rec.ExpirationDate.Before(prev.ExpirationDate) {
				// found an earlier expiration for this tea: update earliestRec and candidate expiration
				earliestRec[idCommon] = rec
				if idx, ok := idToIdx[uid]; ok {
					candidates[idx].Expiration = rec.ExpirationDate
				}
			}
		}
	}

	if len(earliestRec) == 0 {
		return nil, ErrNoTeas
	}

	// Weather and recent consumption (best-effort)
	w, wErr := r.CurrentCyprus(ctx)
	if wErr != nil && r.log != nil {
		r.log.WithField(logKeyUser, user.ID.String()).WithField(logKeyErr, wErr).Debug("tea_of_day weather fetch failed")
	}

	recent, recErr := r.consumption.Recent(ctx, user.ID, now.Add(-96*time.Hour))
	if recErr != nil {
		if r.log != nil {
			r.log.WithField(logKeyUser, user.ID.String()).WithField(logKeyErr, recErr).Debug("tea_of_day recent fetch failed")
		}
		recent = nil
	}

	lastBy := make(map[uuid.UUID]time.Time, len(recent))
	for _, c := range recent {
		if t, ok := lastBy[c.TeaID]; !ok || c.Time.After(t) {
			lastBy[c.TeaID] = c.Time
		}
	}

	ctxScores, ctxErr := r.ContextScores(ctx, names, w, now.Weekday())
	if ctxErr != nil {
		if r.log != nil {
			r.log.WithField("user", user.ID.String()).WithField("err", ctxErr).Debug("tea_of_the_day scoring failed")
		}
		ctxScores = make(map[string]int)
	}
	aiScores := make(map[uuid.UUID]int, len(ctxScores))
	for name, score := range ctxScores {
		if id, ok := nameToID[strings.ToLower(strings.TrimSpace(name))]; ok {
			aiScores[id] = score
		}
	}

	// High-level context log
	if r.log != nil {
		weekday := now.Weekday().String()
		wStr := w.String()
		r.log.
			WithField(logKeyUser, user.ID.String()).
			WithField(logKeyWeekday, weekday).
			WithField(logKeyWeather, wStr).
			WithField("candidates", len(candidates)).
			Debug("tea_of_day context")
	}

	// Delegate detailed candidate and selection logging to scoring package
	var bestID uuid.UUID
	if r.log != nil {
		best, _ := scoring.SelectBestWithLogging(aiScores, candidates, lastBy, now, func(fields map[string]interface{}, msg string) {
			entry := r.log.
				WithField(logKeyUser, user.ID.String()).
				WithField(logKeyWeekday, now.Weekday().String()).
				WithField(logKeyWeather, w.String())
			for k, v := range fields {
				entry = entry.WithField(k, v)
			}
			entry.Debug(msg)
		})
		bestID = best
	} else {
		best, _ := scoring.SelectBest(aiScores, candidates, lastBy, now)
		bestID = best
	}

	if bestID == uuid.Nil {
		return nil, ErrNoTeaCandidates
	}

	if err := r.consumption.Record(ctx, user.ID, bestID, now); err != nil && r.log != nil {
		r.log.WithField(logKeyUser, user.ID.String()).WithField(logKeyErr, err).Debug("tea_of_day record consumption failed")
	}

	// Build QRRecord for the selected tea using the earliest record we observed
	qrr := earliestRec[common.ID(bestID)]
	if qrr == nil {
		return nil, ErrNoTeaCandidates
	}

	res := &model.TeaOfTheDay{Tea: qrr, Date: now}
	r.todCache.Set(user.ID, res, now)
	return res, nil
}

// OnCreateTea is the resolver for the onCreateTea field.
func (r *subscriptionResolver) OnCreateTea(ctx context.Context) (<-chan *model.Tea, error) {
	ch, err := r.teaData.SubscribeOnCreate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnUpdateTea is the resolver for the onUpdateTea field.
func (r *subscriptionResolver) OnUpdateTea(ctx context.Context) (<-chan *model.Tea, error) {
	r.log.Debug("subscribe on update")

	ch, err := r.teaData.SubscribeOnUpdate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnDeleteTea is the resolver for the onDeleteTea field.
func (r *subscriptionResolver) OnDeleteTea(ctx context.Context) (<-chan common.ID, error) {
	ch, err := r.teaData.SubscribeOnDelete(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnCreateTagCategory is the resolver for the onCreateTagCategory field.
func (r *subscriptionResolver) OnCreateTagCategory(ctx context.Context) (<-chan *model.TagCategory, error) {
	ch, err := r.SubscribeOnCreateCategory(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnUpdateTagCategory is the resolver for the onUpdateTagCategory field.
func (r *subscriptionResolver) OnUpdateTagCategory(ctx context.Context) (<-chan *model.TagCategory, error) {
	return r.SubscribeOnUpdateCategory(ctx)
}

// OnDeleteTagCategory is the resolver for the onDeleteTagCategory field.
func (r *subscriptionResolver) OnDeleteTagCategory(ctx context.Context) (<-chan common.ID, error) {
	return r.SubscribeOnDeleteCategory(ctx)
}

// OnCreateTag is the resolver for the onCreateTag field.
func (r *subscriptionResolver) OnCreateTag(ctx context.Context) (<-chan *model.Tag, error) {
	ch, err := r.tagManager.SubscribeOnCreate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnUpdateTag is the resolver for the onUpdateTag field.
func (r *subscriptionResolver) OnUpdateTag(ctx context.Context) (<-chan *model.Tag, error) {
	ch, err := r.tagManager.SubscribeOnUpdate(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnDeleteTag is the resolver for the onDeleteTag field.
func (r *subscriptionResolver) OnDeleteTag(ctx context.Context) (<-chan common.ID, error) {
	ch, err := r.tagManager.SubscribeOnDelete(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnAddTagToTea is the resolver for the onAddTagToTea field.
func (r *subscriptionResolver) OnAddTagToTea(ctx context.Context) (<-chan *model.Tea, error) {
	ch, err := r.SubscribeOnAddTagToTea(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// OnDeleteTagFromTea is the resolver for the onDeleteTagFromTea field.
func (r *subscriptionResolver) OnDeleteTagFromTea(ctx context.Context) (<-chan *model.Tea, error) {
	ch, err := r.SubscribeOnDeleteTagToTea(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return ch, nil
}

// StartGenerateDescription is the resolver for the startGenerateDescription field.
func (r *subscriptionResolver) StartGenerateDescription(ctx context.Context, name string) (<-chan string, error) {
	res := make(chan string, 1)
	if err := r.ai.StartGenerateDescription(ctx, name, res); err != nil {
		return nil, castGQLError(ctx, err)
	}

	return res, nil
}

// RecommendTea is the resolver for the recommendTea field.
func (r *subscriptionResolver) RecommendTea(ctx context.Context, collectionID common.ID, feelings string) (<-chan string, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	wth, err := r.CurrentCyprus(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	records, err := r.ListRecords(ctx, uuid.UUID(collectionID), user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	if len(records) == 0 {
		return nil, ErrNoTeas
	}

	teas := make([]rootCommon.Tea, len(records))

	for i, rec := range records {
		teas[i] = rec.Tea.ToCommonTea()
	}

	res := make(chan string, 1000)
	if err = r.RecommendTeaStream(ctx, teas, wth, feelings, res); err != nil {
		return nil, castGQLError(ctx, err)
	}

	return res, nil
}

// Category is the resolver for the category field.
func (r *tagResolver) Category(ctx context.Context, obj *model.Tag) (*model.TagCategory, error) {
	if obj.Category == nil {
		return nil, nil //nolint:nilnil // GraphQL field can legitimately be null without error
	}

	if obj.Category.Name != "" {
		return obj.Category, nil
	}

	cat, err := r.GetCategory(ctx, uuid.UUID(obj.Category.ID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return &model.TagCategory{
		ID:   common.ID(cat.ID),
		Name: cat.Name,
	}, nil
}

// Tags is the resolver for the tags field.
func (r *tagCategoryResolver) Tags(ctx context.Context, obj *model.TagCategory, name *string) ([]*model.Tag, error) {
	var cat uuid.UUID
	if obj != nil {
		cat = uuid.UUID(obj.ID)
	}

	tags, err := r.tagManager.List(ctx, name, &cat)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	result := make([]*model.Tag, len(tags))
	if len(tags) == 0 {
		return result, nil
	}

	categories, err := r.ListCategory(ctx, nil)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	catMap := map[uuid.UUID]*model.TagCategory{}
	for _, ctg := range categories {
		catMap[ctg.ID] = &model.TagCategory{
			ID:   common.ID(ctg.ID),
			Name: ctg.Name,
		}
	}

	for i, tag := range tags {
		result[i] = &model.Tag{
			ID:       common.ID(tag.ID),
			Name:     tag.Name,
			Color:    tag.Color,
			Category: catMap[tag.CategoryID],
		}
	}

	return result, nil
}

// Tags is the resolver for the tags field.
func (r *teaResolver) Tags(ctx context.Context, obj *model.Tea) ([]*model.Tag, error) {
	tags, err := r.ListByTea(ctx, uuid.UUID(obj.ID))
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	result := make([]*model.Tag, len(tags))
	for i, t := range tags {
		result[i] = &model.Tag{
			ID:       common.ID(t.ID),
			Name:     t.Name,
			Color:    t.Color,
			Category: &model.TagCategory{ID: common.ID(t.CategoryID)},
		}
	}

	return result, nil
}

// Collections is the resolver for the collections field.
func (r *userResolver) Collections(ctx context.Context, obj *model.User) ([]*model.Collection, error) {
	// Delegate to query-level collections (current authenticated user)
	cols, err := r.Query().Collections(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	return cols, nil
}

// Notifications is the resolver for the notifications field.
func (r *userResolver) Notifications(ctx context.Context, obj *model.User) ([]*model.Notification, error) {
	user, err := authPkg.GetUser(ctx)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	notifications, err := r.notificationsManager.Notifications(ctx, user.ID)
	if err != nil {
		return nil, castGQLError(ctx, err)
	}

	res := make([]*model.Notification, len(notifications))

	for i, not := range notifications {
		t := new(model.NotificationType)
		t.FromCommon(not.Type)
		res[i] = &model.Notification{Type: *t}
	}

	return res, nil
}

// Collection returns generated.CollectionResolver implementation.
func (r *Resolver) Collection() generated.CollectionResolver { return &collectionResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// Tag returns generated.TagResolver implementation.
func (r *Resolver) Tag() generated.TagResolver { return &tagResolver{r} }

// TagCategory returns generated.TagCategoryResolver implementation.
func (r *Resolver) TagCategory() generated.TagCategoryResolver { return &tagCategoryResolver{r} }

// Tea returns generated.TeaResolver implementation.
func (r *Resolver) Tea() generated.TeaResolver { return &teaResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type collectionResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
type tagCategoryResolver struct{ *Resolver }
type teaResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
