// Code generated by sqlc. DO NOT EDIT.

package pgstore

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Queries struct {
	db *sql.DB
}

func New(db *sql.DB) *Queries {
	return &Queries{db: db}
}

func (q *Queries) DB() *sql.DB {
	return q.db
}

// Users

type UpsertUserParams struct {
	ID      uuid.UUID
	AppleID string
}

type User struct {
	ID        uuid.UUID
	AppleID   string
	CreatedAt time.Time
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (id, apple_id)
VALUES ($1, $2)
ON CONFLICT (apple_id)
DO UPDATE SET apple_id = EXCLUDED.apple_id
RETURNING id, apple_id, created_at`

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, upsertUser, arg.ID, arg.AppleID)
	var i User
	err := row.Scan(&i.ID, &i.AppleID, &i.CreatedAt)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, apple_id, created_at
FROM users
ORDER BY created_at DESC`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.AppleID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Teas

type InsertTeaParams struct {
	ID          uuid.UUID
	Name        string
	Type        string
	Description sql.NullString
}

type Tea struct {
	ID          uuid.UUID
	Name        string
	Type        string
	Description sql.NullString
	CreatedAt   time.Time
}

const insertTea = `-- name: InsertTea :one
INSERT INTO teas (id, name, type, description)
VALUES ($1, $2, $3, $4)
RETURNING id, name, type, description, created_at`

func (q *Queries) InsertTea(ctx context.Context, arg InsertTeaParams) (Tea, error) {
	row := q.db.QueryRowContext(ctx, insertTea, arg.ID, arg.Name, arg.Type, arg.Description)
	var i Tea
	err := row.Scan(&i.ID, &i.Name, &i.Type, &i.Description, &i.CreatedAt)
	return i, err
}

type UpdateTeaParams struct {
	ID          uuid.UUID
	Name        string
	Type        string
	Description sql.NullString
}

const updateTea = `-- name: UpdateTea :one
UPDATE teas
SET name = $2,
    type = $3,
    description = $4
WHERE id = $1
RETURNING id, name, type, description, created_at`

func (q *Queries) UpdateTea(ctx context.Context, arg UpdateTeaParams) (Tea, error) {
	row := q.db.QueryRowContext(ctx, updateTea, arg.ID, arg.Name, arg.Type, arg.Description)
	var i Tea
	err := row.Scan(&i.ID, &i.Name, &i.Type, &i.Description, &i.CreatedAt)
	return i, err
}

const deleteTea = `-- name: DeleteTea :exec
DELETE FROM teas WHERE id = $1`

func (q *Queries) DeleteTea(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTea, id)
	return err
}

const getTea = `-- name: GetTea :one
SELECT id, name, type, description, created_at
FROM teas
WHERE id = $1`

func (q *Queries) GetTea(ctx context.Context, id uuid.UUID) (Tea, error) {
	row := q.db.QueryRowContext(ctx, getTea, id)
	var i Tea
	err := row.Scan(&i.ID, &i.Name, &i.Type, &i.Description, &i.CreatedAt)
	return i, err
}

const listTeas = `-- name: ListTeas :many
SELECT id, name, type, description, created_at
FROM teas
ORDER BY created_at DESC`

func (q *Queries) ListTeas(ctx context.Context) ([]Tea, error) {
	rows, err := q.db.QueryContext(ctx, listTeas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tea
	for rows.Next() {
		var i Tea
		if err := rows.Scan(&i.ID, &i.Name, &i.Type, &i.Description, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeasByPrefix = `-- name: SearchTeasByPrefix :many
SELECT id, name, type, description, created_at
FROM teas
WHERE lower(name) LIKE lower($1) || '%'
ORDER BY name ASC
LIMIT $2`

func (q *Queries) SearchTeasByPrefix(ctx context.Context, name string, limit int32) ([]Tea, error) {
	rows, err := q.db.QueryContext(ctx, searchTeasByPrefix, name, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tea
	for rows.Next() {
		var i Tea
		if err := rows.Scan(&i.ID, &i.Name, &i.Type, &i.Description, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Tag categories and tags

type TagCategory struct {
	ID   uuid.UUID
	Name string
}

type InsertTagCategoryParams struct {
	ID   uuid.UUID
	Name string
}

const insertTagCategory = `-- name: InsertTagCategory :one
INSERT INTO tag_categories (id, name)
VALUES ($1, $2)
RETURNING id, name`

func (q *Queries) InsertTagCategory(ctx context.Context, arg InsertTagCategoryParams) (TagCategory, error) {
	row := q.db.QueryRowContext(ctx, insertTagCategory, arg.ID, arg.Name)
	var i TagCategory
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

type UpdateTagCategoryParams struct {
	ID   uuid.UUID
	Name string
}

const updateTagCategory = `-- name: UpdateTagCategory :one
UPDATE tag_categories
SET name = $2
WHERE id = $1
RETURNING id, name`

func (q *Queries) UpdateTagCategory(ctx context.Context, arg UpdateTagCategoryParams) (TagCategory, error) {
	row := q.db.QueryRowContext(ctx, updateTagCategory, arg.ID, arg.Name)
	var i TagCategory
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteTagCategory = `-- name: DeleteTagCategory :exec
DELETE FROM tag_categories WHERE id = $1`

func (q *Queries) DeleteTagCategory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTagCategory, id)
	return err
}

const listTagCategories = `-- name: ListTagCategories :many
SELECT id, name
FROM tag_categories
ORDER BY name ASC`

func (q *Queries) ListTagCategories(ctx context.Context) ([]TagCategory, error) {
	rows, err := q.db.QueryContext(ctx, listTagCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TagCategory
	for rows.Next() {
		var i TagCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagCategory = `-- name: GetTagCategory :one
SELECT id, name
FROM tag_categories
WHERE id = $1`

func (q *Queries) GetTagCategory(ctx context.Context, id uuid.UUID) (TagCategory, error) {
	row := q.db.QueryRowContext(ctx, getTagCategory, id)
	var i TagCategory
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const searchTagCategories = `-- name: SearchTagCategories :many
SELECT id, name
FROM tag_categories
WHERE lower(name) LIKE lower($1) || '%'
ORDER BY name ASC`

func (q *Queries) SearchTagCategories(ctx context.Context, prefix string) ([]TagCategory, error) {
	rows, err := q.db.QueryContext(ctx, searchTagCategories, prefix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TagCategory
	for rows.Next() {
		var i TagCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByCategory = `-- name: ListTagsByCategory :many
SELECT id, name, color, category_id
FROM tags
WHERE category_id = $1
ORDER BY name ASC`

type Tag struct {
	ID         uuid.UUID
	Name       string
	Color      string
	CategoryID uuid.UUID
}

func (q *Queries) ListTagsByCategory(ctx context.Context, categoryID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteTagsByCategory = `-- name: DeleteTagsByCategory :exec
DELETE FROM tags
WHERE category_id = $1`

func (q *Queries) DeleteTagsByCategory(ctx context.Context, categoryID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTagsByCategory, categoryID)
	return err
}

type InsertTagParams struct {
	ID         uuid.UUID
	Name       string
	Color      string
	CategoryID uuid.UUID
}

const insertTag = `-- name: InsertTag :one
INSERT INTO tags (id, name, color, category_id)
VALUES ($1, $2, $3, $4)
RETURNING id, name, color, category_id`

func (q *Queries) InsertTag(ctx context.Context, arg InsertTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, insertTag, arg.ID, arg.Name, arg.Color, arg.CategoryID)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID)
	return i, err
}

type UpdateTagParams struct {
	ID    uuid.UUID
	Name  string
	Color string
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET name = $2,
    color = $3
WHERE id = $1
RETURNING id, name, color, category_id`

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, updateTag, arg.ID, arg.Name, arg.Color)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID)
	return i, err
}

type ChangeTagCategoryParams struct {
	ID         uuid.UUID
	CategoryID uuid.UUID
}

const changeTagCategory = `-- name: ChangeTagCategory :one
UPDATE tags
SET category_id = $2
WHERE id = $1
RETURNING id, name, color, category_id`

func (q *Queries) ChangeTagCategory(ctx context.Context, arg ChangeTagCategoryParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, changeTagCategory, arg.ID, arg.CategoryID)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID)
	return i, err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = $1`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTag, id)
	return err
}

const getTag = `-- name: GetTag :one
SELECT id, name, color, category_id
FROM tags
WHERE id = $1`

func (q *Queries) GetTag(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTag, id)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID)
	return i, err
}

const listTags = `-- name: ListTags :many
SELECT id, name, color, category_id
FROM tags
ORDER BY name ASC`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByName = `-- name: ListTagsByName :many
SELECT id, name, color, category_id
FROM tags
WHERE lower(name) LIKE lower($1) || '%'
ORDER BY name ASC`

func (q *Queries) ListTagsByName(ctx context.Context, prefix string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByName, prefix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByCategoryFilter = `-- name: ListTagsByCategoryFilter :many
SELECT id, name, color, category_id
FROM tags
WHERE category_id = $1
ORDER BY name ASC`

func (q *Queries) ListTagsByCategoryFilter(ctx context.Context, categoryID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByCategoryFilter, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByNameCategory = `-- name: ListTagsByNameCategory :many
SELECT id, name, color, category_id
FROM tags
WHERE lower(name) LIKE lower($1) || '%'
  AND category_id = $2
ORDER BY name ASC`

func (q *Queries) ListTagsByNameCategory(ctx context.Context, prefix string, categoryID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByNameCategory, prefix, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addTagToTea = `-- name: AddTagToTea :exec
INSERT INTO tea_tags (tea_id, tag_id)
VALUES ($1, $2)
ON CONFLICT (tea_id, tag_id) DO NOTHING`

func (q *Queries) AddTagToTea(ctx context.Context, teaID uuid.UUID, tagID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, addTagToTea, teaID, tagID)
	return err
}

const deleteTagFromTea = `-- name: DeleteTagFromTea :exec
DELETE FROM tea_tags WHERE tea_id = $1 AND tag_id = $2`

func (q *Queries) DeleteTagFromTea(ctx context.Context, teaID uuid.UUID, tagID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTagFromTea, teaID, tagID)
	return err
}

const listTagsByTea = `-- name: ListTagsByTea :many
SELECT t.id, t.name, t.color, t.category_id
FROM tea_tags tt
JOIN tags t ON t.id = tt.tag_id
WHERE tt.tea_id = $1
ORDER BY t.name ASC`

func (q *Queries) ListTagsByTea(ctx context.Context, teaID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByTea, teaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// QR records

type QRRecord struct {
	ID             uuid.UUID
	TeaID          uuid.UUID
	BoilingTemp    int32
	ExpirationDate time.Time
	CreatedAt      time.Time
}

const upsertQR = `-- name: UpsertQR :exec
INSERT INTO qr_records (id, tea_id, boiling_temp, expiration_date)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE
SET tea_id = EXCLUDED.tea_id,
    boiling_temp = EXCLUDED.boiling_temp,
    expiration_date = EXCLUDED.expiration_date`

func (q *Queries) UpsertQR(ctx context.Context, arg QRRecord) error {
	_, err := q.db.ExecContext(ctx, upsertQR, arg.ID, arg.TeaID, arg.BoilingTemp, arg.ExpirationDate)
	return err
}

const getQR = `-- name: GetQR :one
SELECT id, tea_id, boiling_temp, expiration_date, created_at
FROM qr_records
WHERE id = $1`

func (q *Queries) GetQR(ctx context.Context, id uuid.UUID) (QRRecord, error) {
	row := q.db.QueryRowContext(ctx, getQR, id)
	var i QRRecord
	err := row.Scan(&i.ID, &i.TeaID, &i.BoilingTemp, &i.ExpirationDate, &i.CreatedAt)
	return i, err
}

// Collections

type InsertCollectionParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Name   string
}

type Collection struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Name      string
	CreatedAt time.Time
}

const insertCollection = `-- name: InsertCollection :one
INSERT INTO collections (id, user_id, name)
VALUES ($1, $2, $3)
RETURNING id, user_id, name, created_at`

func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, insertCollection, arg.ID, arg.UserID, arg.Name)
	var i Collection
	err := row.Scan(&i.ID, &i.UserID, &i.Name, &i.CreatedAt)
	return i, err
}

const insertCollectionItem = `-- name: InsertCollectionItem :exec
INSERT INTO collection_qr_items (collection_id, qr_id)
VALUES ($1, $2)
ON CONFLICT (collection_id, qr_id) DO NOTHING`

func (q *Queries) InsertCollectionItem(ctx context.Context, collectionID uuid.UUID, qrID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, insertCollectionItem, collectionID, qrID)
	return err
}

const insertCollectionItems = `-- name: InsertCollectionItems :exec
INSERT INTO collection_qr_items (collection_id, qr_id)
SELECT $1, x
FROM unnest($2::uuid[]) AS t(x)
ON CONFLICT (collection_id, qr_id) DO NOTHING`

func (q *Queries) InsertCollectionItems(ctx context.Context, collectionID uuid.UUID, qrIDs []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, insertCollectionItems, collectionID, qrIDs)
	return err
}

const deleteCollectionItem = `-- name: DeleteCollectionItem :exec
DELETE FROM collection_qr_items
WHERE collection_id = $1 AND qr_id = $2`

func (q *Queries) DeleteCollectionItem(ctx context.Context, collectionID uuid.UUID, qrID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCollectionItem, collectionID, qrID)
	return err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections
WHERE id = $1 AND user_id = $2`

func (q *Queries) DeleteCollection(ctx context.Context, id uuid.UUID, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCollection, id, userID)
	return err
}

const listCollections = `-- name: ListCollections :many
SELECT id, user_id, name, created_at
FROM collections
WHERE user_id = $1
ORDER BY created_at DESC`

func (q *Queries) ListCollections(ctx context.Context, userID uuid.UUID) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(&i.ID, &i.UserID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollection = `-- name: GetCollection :one
SELECT id, user_id, name, created_at
FROM collections
WHERE id = $1 AND user_id = $2`

func (q *Queries) GetCollection(ctx context.Context, id uuid.UUID, userID uuid.UUID) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollection, id, userID)
	var i Collection
	err := row.Scan(&i.ID, &i.UserID, &i.Name, &i.CreatedAt)
	return i, err
}

type ListCollectionRecordsRow struct {
	QRID           uuid.UUID
	TeaID          uuid.UUID
	Name           string
	Type           string
	Description    sql.NullString
	BoilingTemp    int32
	ExpirationDate time.Time
}

const listCollectionRecords = `-- name: ListCollectionRecords :many
SELECT
  q.id AS qr_id,
  t.id AS tea_id,
  t.name,
  t.type,
  t.description,
  q.boiling_temp,
  q.expiration_date
FROM collection_qr_items c
JOIN qr_records q ON q.id = c.qr_id
JOIN teas t ON t.id = q.tea_id
WHERE c.collection_id = $1
ORDER BY q.expiration_date ASC`

func (q *Queries) ListCollectionRecords(ctx context.Context, collectionID uuid.UUID) ([]ListCollectionRecordsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCollectionRecords, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCollectionRecordsRow
	for rows.Next() {
		var i ListCollectionRecordsRow
		if err := rows.Scan(&i.QRID, &i.TeaID, &i.Name, &i.Type, &i.Description, &i.BoilingTemp, &i.ExpirationDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Devices

const insertDevice = `-- name: InsertDevice :exec
INSERT INTO devices (id, user_id, token)
VALUES ($1, $2, $3)
ON CONFLICT (id) DO NOTHING`

func (q *Queries) InsertDevice(ctx context.Context, id uuid.UUID, userID uuid.UUID, token string) error {
	_, err := q.db.ExecContext(ctx, insertDevice, id, userID, token)
	return err
}

const updateDeviceToken = `-- name: UpdateDeviceToken :exec
UPDATE devices
SET token = $2
WHERE id = $1`

func (q *Queries) UpdateDeviceToken(ctx context.Context, id uuid.UUID, token string) (int64, error) {
	res, err := q.db.ExecContext(ctx, updateDeviceToken, id, token)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

const listDeviceTokens = `-- name: ListDeviceTokens :many
SELECT token
FROM devices
WHERE user_id = $1
ORDER BY created_at DESC`

func (q *Queries) ListDeviceTokens(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDeviceTokens, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var token string
		if err := rows.Scan(&token); err != nil {
			return nil, err
		}
		items = append(items, token)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Notifications

type Notification struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Type      int16
	CreatedAt time.Time
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, user_id, type, created_at
FROM notifications
WHERE user_id = $1
ORDER BY created_at DESC`

func (q *Queries) ListNotifications(ctx context.Context, userID uuid.UUID) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, listNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(&i.ID, &i.UserID, &i.Type, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Consumptions

type InsertConsumptionParams struct {
	UserID uuid.UUID
	Ts     time.Time
	TeaID  uuid.UUID
}

const insertConsumption = `-- name: InsertConsumption :exec
INSERT INTO consumptions (user_id, ts, tea_id)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, ts, tea_id) DO NOTHING`

func (q *Queries) InsertConsumption(ctx context.Context, arg InsertConsumptionParams) error {
	_, err := q.db.ExecContext(ctx, insertConsumption, arg.UserID, arg.Ts, arg.TeaID)
	return err
}

const deleteConsumptionsBefore = `-- name: DeleteConsumptionsBefore :exec
DELETE FROM consumptions
WHERE user_id = $1 AND ts < $2`

func (q *Queries) DeleteConsumptionsBefore(ctx context.Context, userID uuid.UUID, cutoff time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteConsumptionsBefore, userID, cutoff)
	return err
}

type ListConsumptionsSinceParams struct {
	UserID uuid.UUID
	Since  time.Time
}

type Consumption struct {
	Ts    time.Time
	TeaID uuid.UUID
}

const listConsumptionsSince = `-- name: ListConsumptionsSince :many
SELECT ts, tea_id
FROM consumptions
WHERE user_id = $1 AND ts >= $2
ORDER BY ts DESC`

func (q *Queries) ListConsumptionsSince(ctx context.Context, arg ListConsumptionsSinceParams) ([]Consumption, error) {
	rows, err := q.db.QueryContext(ctx, listConsumptionsSince, arg.UserID, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consumption
	for rows.Next() {
		var i Consumption
		if err := rows.Scan(&i.Ts, &i.TeaID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
