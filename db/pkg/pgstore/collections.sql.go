// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: collections.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections
WHERE id = $1 AND user_id = $2
`

type DeleteCollectionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteCollection(ctx context.Context, arg DeleteCollectionParams) error {
	_, err := q.db.Exec(ctx, deleteCollection, arg.ID, arg.UserID)
	return err
}

const deleteCollectionItem = `-- name: DeleteCollectionItem :exec
DELETE FROM collection_qr_items
WHERE collection_id = $1 AND qr_id = $2
`

type DeleteCollectionItemParams struct {
	CollectionID uuid.UUID `json:"collection_id"`
	QrID         uuid.UUID `json:"qr_id"`
}

func (q *Queries) DeleteCollectionItem(ctx context.Context, arg DeleteCollectionItemParams) error {
	_, err := q.db.Exec(ctx, deleteCollectionItem, arg.CollectionID, arg.QrID)
	return err
}

const getCollection = `-- name: GetCollection :one
SELECT id, user_id, name, created_at
FROM collections
WHERE id = $1 AND user_id = $2
`

type GetCollectionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetCollection(ctx context.Context, arg GetCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollection, arg.ID, arg.UserID)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const insertCollection = `-- name: InsertCollection :one
INSERT INTO collections (id, user_id, name)
VALUES ($1, $2, $3)
RETURNING id, user_id, name, created_at
`

type InsertCollectionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
	Name   string    `json:"name"`
}

func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, insertCollection, arg.ID, arg.UserID, arg.Name)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const insertCollectionItem = `-- name: InsertCollectionItem :exec
INSERT INTO collection_qr_items (collection_id, qr_id)
VALUES ($1, $2)
ON CONFLICT (collection_id, qr_id) DO NOTHING
`

type InsertCollectionItemParams struct {
	CollectionID uuid.UUID `json:"collection_id"`
	QrID         uuid.UUID `json:"qr_id"`
}

func (q *Queries) InsertCollectionItem(ctx context.Context, arg InsertCollectionItemParams) error {
	_, err := q.db.Exec(ctx, insertCollectionItem, arg.CollectionID, arg.QrID)
	return err
}

const listCollectionRecords = `-- name: ListCollectionRecords :many
SELECT
  q.id AS qr_id,
  t.id AS tea_id,
  t.name,
  t.type,
  t.description,
  q.boiling_temp,
  q.expiration_date
FROM collection_qr_items c
JOIN qr_records q ON q.id = c.qr_id
JOIN teas t ON t.id = q.tea_id
WHERE c.collection_id = $1
ORDER BY q.expiration_date ASC
`

type ListCollectionRecordsRow struct {
	QrID           uuid.UUID   `json:"qr_id"`
	TeaID          uuid.UUID   `json:"tea_id"`
	Name           string      `json:"name"`
	Type           string      `json:"type"`
	Description    pgtype.Text `json:"description"`
	BoilingTemp    int32       `json:"boiling_temp"`
	ExpirationDate time.Time   `json:"expiration_date"`
}

func (q *Queries) ListCollectionRecords(ctx context.Context, collectionID uuid.UUID) ([]ListCollectionRecordsRow, error) {
	rows, err := q.db.Query(ctx, listCollectionRecords, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCollectionRecordsRow{}
	for rows.Next() {
		var i ListCollectionRecordsRow
		if err := rows.Scan(
			&i.QrID,
			&i.TeaID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.BoilingTemp,
			&i.ExpirationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollections = `-- name: ListCollections :many
SELECT id, user_id, name, created_at
FROM collections
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCollections(ctx context.Context, userID uuid.UUID) ([]Collection, error) {
	rows, err := q.db.Query(ctx, listCollections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Collection{}
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
