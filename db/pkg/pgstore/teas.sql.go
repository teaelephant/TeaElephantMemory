// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: teas.sql

package pgstore

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteTea = `-- name: DeleteTea :exec
DELETE FROM teas WHERE id = $1
`

func (q *Queries) DeleteTea(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTea, id)
	return err
}

const getTea = `-- name: GetTea :one
SELECT id, name, type, description, created_at
FROM teas
WHERE id = $1
`

func (q *Queries) GetTea(ctx context.Context, id uuid.UUID) (Tea, error) {
	row := q.db.QueryRow(ctx, getTea, id)
	var i Tea
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const insertTea = `-- name: InsertTea :one
INSERT INTO teas (id, name, type, description)
VALUES ($1, $2, $3, $4)
RETURNING id, name, type, description, created_at
`

type InsertTeaParams struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Type        string      `json:"type"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) InsertTea(ctx context.Context, arg InsertTeaParams) (Tea, error) {
	row := q.db.QueryRow(ctx, insertTea,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Description,
	)
	var i Tea
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listTeas = `-- name: ListTeas :many
SELECT id, name, type, description, created_at
FROM teas
ORDER BY created_at DESC
`

func (q *Queries) ListTeas(ctx context.Context) ([]Tea, error) {
	rows, err := q.db.Query(ctx, listTeas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tea{}
	for rows.Next() {
		var i Tea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeasByPrefix = `-- name: SearchTeasByPrefix :many
SELECT id, name, type, description, created_at
FROM teas
WHERE lower(name) LIKE lower($1) || '%'
ORDER BY name ASC
LIMIT $2
`

type SearchTeasByPrefixParams struct {
	Lower string `json:"lower"`
	Limit int32  `json:"limit"`
}

func (q *Queries) SearchTeasByPrefix(ctx context.Context, arg SearchTeasByPrefixParams) ([]Tea, error) {
	rows, err := q.db.Query(ctx, searchTeasByPrefix, arg.Lower, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tea{}
	for rows.Next() {
		var i Tea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTea = `-- name: UpdateTea :one
UPDATE teas
SET name = $2,
    type = $3,
    description = $4
WHERE id = $1
RETURNING id, name, type, description, created_at
`

type UpdateTeaParams struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Type        string      `json:"type"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateTea(ctx context.Context, arg UpdateTeaParams) (Tea, error) {
	row := q.db.QueryRow(ctx, updateTea,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Description,
	)
	var i Tea
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
