// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: qr.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getQR = `-- name: GetQR :one
SELECT id, tea_id, boiling_temp, expiration_date, created_at
FROM qr_records
WHERE id = $1
`

func (q *Queries) GetQR(ctx context.Context, id uuid.UUID) (QrRecord, error) {
	row := q.db.QueryRow(ctx, getQR, id)
	var i QrRecord
	err := row.Scan(
		&i.ID,
		&i.TeaID,
		&i.BoilingTemp,
		&i.ExpirationDate,
		&i.CreatedAt,
	)
	return i, err
}

const upsertQR = `-- name: UpsertQR :exec
INSERT INTO qr_records (id, tea_id, boiling_temp, expiration_date)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE
SET tea_id = EXCLUDED.tea_id,
    boiling_temp = EXCLUDED.boiling_temp,
    expiration_date = EXCLUDED.expiration_date
`

type UpsertQRParams struct {
	ID             uuid.UUID `json:"id"`
	TeaID          uuid.UUID `json:"tea_id"`
	BoilingTemp    int32     `json:"boiling_temp"`
	ExpirationDate time.Time `json:"expiration_date"`
}

func (q *Queries) UpsertQR(ctx context.Context, arg UpsertQRParams) error {
	_, err := q.db.Exec(ctx, upsertQR,
		arg.ID,
		arg.TeaID,
		arg.BoilingTemp,
		arg.ExpirationDate,
	)
	return err
}
